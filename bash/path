# -*- sh -*-

## True if $1 is inpath
function be_inpath { echo "$PATH" | /bin/grep -Eq "(^|:)$1($|:)"; }

## Append $1 to PATH if it exists, without duplication
function be_addpath { be_inpath "$1" || [[ -d "$1" ]] && export PATH="$PATH:$1"; }

## Prepend $1 to PATH if it exists, without duplication
function be_prepath { be_inpath "$1" || [[ -d "$1" ]] && export PATH="$1:$PATH"; }

## Remove $1 from PATH
function be_rmpath {
    export PATH="$(echo $PATH | sed -e "s=^${1}:==;s=:${1}$==;s=:${1}:=:=")";
}

## Find exectuables in PATH, grepping names for $@
function be_greppath {
    find "${PATH//:/ }" -executable -type f -printf "%f\n" | grep "$@"
}

## Sort PATH, leaving only unique elements
function be_uniqpath {
    export PATH="$(echo $PATH | sed 's/:/\n/g' | sort -u | sed -e '1{$p;x;d;};{H;$!d;x;s/\n/:/g;b;};x;s/\n//g;${p;x;}')"
}

# From http://aijazansari.com/2010/02/20/navigating-the-directory-stack-in-bash/
# An enhanced 'cd' - push directories onto a stack as you navigate to it.
# The current directory is at the top of the stack.
#
function be_stack_cd {
    if [[ -n "$1" ]]; then
        # use the pushd bash command to push the directory
        # to the top of the stack, and enter that directory
        pushd "$1"
    else
        # the normal cd behavior is to enter $HOME if no
        # arguments are specified
        pushd "$HOME"
    fi
}
# Promt the user for an entry.
# If the user enters 'p', pop the stack.
# If the user enters a number, move that
# directory to the top of the stack
# If the user enters 'q', don't do anything.
#
function be_stack_select {
    dirs -v
    echo -n "#: "
    read dir
    if [[ $dir = 'p' ]]; then
        pushd > /dev/null
    elif [[ $dir != 'q' ]]; then
        d=$(dirs -l +$dir);
        popd +$dir > /dev/null
        pushd "$d" > /dev/null
    fi
}
function be_setall_stack {
    alias s=pushd
    alias p=popd
    alias cd=be_stack_cd
    alias d=be_stack_select
}
