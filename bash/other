# wrap_alias takes three arguments:
# $1: The name of the alias
# $2: The command used in the alias
# $3: The arguments in the alias all in one string
# Generate a wrapper completion function (completer) for an alias based on the command 
# and the given arguments, if there is a completer for the command, and 
# set the wrapper as the completer for the alias.
# http://stackoverflow.com/questions/342969/how-do-i-get-bash-completion-to-work-with-aliases
function be_wrap_alias() {
  [[ "$#" == 3 ]] || return 1

  local alias_name="$1"
  local aliased_command="$2"
  local alias_arguments="$3"
  local num_alias_arguments=$(echo "$alias_arguments" | wc -w)
  #echo $alias_name AND $aliased_command AND $alias_arguments

  # The completion currently being used for the aliased command.
  local completion=$(complete -p $aliased_command 2> /dev/null)

  # Only a completer based on a function can be wrapped so look for -F
  # in the current completion. This check will also catch commands
  # with no completer for which $completion will be empty.
  echo $completion | grep -q -- -F || return 0

  local namespace=alias_completion::

  # Extract the name of the completion function from a string that
  # looks like: something -F function_name something
  # First strip the beginning of the string up to the function name by
  # removing "* -F " from the front.
  local completion_function=${completion##* -F }
  # Then strip " *" from the end, leaving only the function name.
  completion_function=${completion_function%% *}

  # Try to prevent an infinite loop by not wrapping a function
  # generated by this function. This can happen when the user runs
  # this twice for an alias like ls='ls --color=auto' or alias l='ls'
  # and alias ls='l foo'
  [[ "${completion_function#$namespace}" != $completion_function ]] && return 0

  local wrapper_name="${namespace}${alias_name}"

  eval "
function ${wrapper_name}() {
  let \"COMP_CWORD+=$num_alias_arguments\"
  args=( \"${alias_arguments}\" )
  COMP_WORDS=( $aliased_command \${args[@]} \${COMP_WORDS[@]:1} )
  $completion_function
  }
"

  # To create the new completion we use the old one with two
  # replacements:
  # 1) Replace the function with the wrapper.
  local new_completion=${completion/-F * /-F $wrapper_name }
  # 2) Replace the command being completed with the alias.
  new_completion="${new_completion% *} $alias_name"

  eval "$new_completion"
}

# For each specified alias, call wrap_alias.
function be_wrap_aliases {
   for cmdname in "$@"; do 
      cmdname="$(alias $cmdname | sed 's/sudo //')"
      eval "$(echo $cmdname | sed -e 's/alias \([^=][^=]*\)='\''\([^ ][^ ]*\) *\(.*\)'\''/be_wrap_alias \1 \2 '\''\3'\'' /')"
   done
}

## Listing, cd, pager aliases
function be_set_lsaliases {
    alias ls='ls --color=auto'  # colorize (ubuntu)
    alias ll='ls -alF'     # long:all (ubuntu)
    alias la='ls -A'       # short:almost-all (ubuntu)
    alias l='ls -CF'       # short:visible (ubuntu)
    alias lr='ls -R'       # short:recursive
    alias l1='ls -1F'      # short:oneperline:visible
    alias lu='ls -lF'      # long:visible
    alias lt='ls -lhvrtF'  # long:visible:timesort:reverse
    alias llr='ls -alR'    # long:all:recursive
    alias l.='ls -ldF .*'  # long:dotfiles
    alias ly='ls -dl -- */'  # long:directories
    #be_wrap_aliases ll la l lr l1 lu lt llr 
    alias ..="cd .."
    alias ...="cd ../.."
    alias ....="cd ../../.."
    alias -- -="cd -"
    alias -- ~="cd ~"
}

## Set extra aliases
function be_set_aliases {
# Ack-grep
    hash ack-grep &>/dev/null && alias a=ack-grep
# Hilighting less
    hash source-highlight &>/dev/null && alias hless=be_hiless
# Awk calculator
    alias c=be_awkeval
# bc evaluator
    alias bce=be_bceval
# Pager, interpreting ascii codes
    alias p='less -R'
# Sudo shortcut
    alias s='sudo'
# Vim with view read-only files
    alias v='be_vim_view'
# Vim with sudo read-only files
    alias vs='be_vim_sudo'
# What services are running here
    alias whatsopen="sudo nmap -sS -O 127.0.0.1"
# Nice process listing
    alias psx="ps hwwaxfo pid,uname,nice,bsdstart,bsdtime,pcpu,pmem,rss,cmd"
# Get full/absolute path to $1
    alias abspath='readlink -f'
# Display top processes by memory usage
    alias pmem='ps aux | sort -nk +4 | tail'
# Prevent crontab accidents
    alias crontab='crontab -i'
# Windows rsync
    alias rsyncw='rsync --modify-window=2 --delete-after --recursive --verbose'
# Debian package management
    alias ac='apt-cache' 
    alias acs='apt-cache search'
    alias ag='sudo apt-get' 
    alias can-has='sudo apt-get install'
    alias agi='sudo apt-get install' 
    alias dq='dpkg-query'
    be_wrap_aliases ac ag can-has agi
}

## Set colors for directory listing 
function be_set_dircolors {
    if hash dircolors &>/dev/null; then
        if [[ -f "~/.dircolors" ]]; then
            eval "$(dircolors -b "~/.dircolors")"
        else
            eval "$(dircolors -b)"
        fi
    fi
    [[ -n "$LS_COLORS" ]] && export GREP_OPTIONS="--color=auto"
}

## Display legend for LS_COLORS 
function be_colorpreview {
   (
       [[ "$LS_COLORS" ]] || eval "$(dircolors)"
       [[ "$LS_COLORS" ]] || eval "$(TERM=xterm dircolors)"
       printf "$LS_COLORS"
   ) | tr : '\n' |
   sed 's/\([^=]*\)=\(.*\)/\x1b[\2m\1\x1b[0m\t\2/'
}

## Set shell options and environment vars
function be_set_shopts {
    export PAGER=less
    export LESS='--LONG-PROMPT --RAW-CONTROL-CHARS'
    export GLOBIGNORE='.:..'
    shopt -s cdspell      # Correct spelling
    shopt -s checkhash    # Look up commands
    shopt -s checkwinsize # Update LINES and COLUMNS after each command
    shopt -s extglob      # Pattern-matching glob features
    shopt -u dotglob      # Do not include .config files in normal glob
    shopt -u failglob     # Don't fail on nomatch, just leave the *'s in
    shopt -u nullglob     # Don't go to null on nomatch, just leave the *'s in
}

# Set terminal title to $@
function be_set_title { echo -ne "\033]2;$@\007"; }

# Set long terminal title 
function be_set_longtitle {
  echo -ne "\033]0;${HOSTNAME%%.*}:${PWD/$HOME/~}\007";
}

# Set short terminal title 
function be_set_shorttitle {
  local wd="${PWD/$HOME/~}";
  local hn="${HOSTNAME%%.*}";
  echo -ne "\033]0;${wd}:${USER:0:1}@${hn}\007";
}

# Set title on each command by calling $1
function be_set_titlecmd {
  if [[ "$TERM" == @(rxvt|xterm) ]]; then
    export PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND;} ${1:-be_set_shorttitle}";
  fi
}

## Integrate "other" options
function be_setall_other {
    be_set_shopts
    be_set_dircolors
    be_set_lsaliases
    be_set_aliases
    be_set_titlecmd
}
